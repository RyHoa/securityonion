import requests 
import helpers
import json
import sys
from pprint import pprint
import os
# support querying for hash, gimphash, tlsh, ssdeep
def loadMetadataFix(file):
    dir = os.path.dirname(os.path.realpath(file))
    filename = os.path.realpath(file).rsplit('\\', 1)[1].split('.')[0]
    with open(str(dir + "\\" + filename + ".json"), "r") as metafile:
        return json.load(metafile)
    
def buildReq(observ_type, observ_value):
    if observ_type == 'gimphash':
        qtype = 'get_gimphash'
    elif observ_type == 'tlsh':
        qtype = 'get_tlsh'
    else:
        qtype = 'get_info'
    return {'query': qtype, observ_type: observ_value}



#first layer is triage tags, then regular tags for summaries, 
#   for tlsh it is going to be number of malware then first malware data.
#       tlsh will be special that it will return number of malware
#       also dev an array of data that record all the API 
#for status first layer is vxcube, then triage[Triage][score], then reverse lab[ReversingLabs][status], then spamhaus[Spamhaus_HBL][detection], then yoroi_yomi (['YOROI_YOMI']['detection'])
def prepareResults(raw, countmal:int):
    # Incomplete
    if raw != {} and raw['query_status'] == 'ok':
        parsed = raw['data'][0]
        if countmal>=2:
            summary=f'there are {countmal} malware associate with the hashes'
        #if there exist a tag then check for triage, if triage not aviaable then get the regular tags value
        else:
            if(parsed['tags']!=''):
                if(parsed['vendor_intel']['Triage']['tags']!=''):
                    summary = parsed['vendor_intel']['Triage']['tags']
            else:
                summary = parsed['tags']


        score= checkscore(raw['data'][0])
        if score!=0:
            if score > 75:
                status = 'threat'
            elif score > 50:
                status = 'caution'
            elif score > 25:
                status = 'info'
            else:
                status = 'ok'
        else:
            status=checkStatus(raw['data'][0])

    elif raw != {} and raw['query_status'] in ['no_result', 'illegal_hash', 'illegal_tlsh','illegal_gimphash','unknown_operation', 'no_gimphash','hash_not_found','no_hash_provided','http_post_expected','no_tlsh','no_results',]:
            status = 'info'
            summary = 'no result'
    else:
            raw = {}
            status = 'caution'
            summary = 'internal_failure'

    results = {'response': raw, 'summary': summary, 'status': status}    
    return results
# second check if there is no score then check these api to get the status
def checkStatus(sData):
    if 'ReversingLabs' in sData:
        status=sData['ReversingLabs']['status']
    elif 'Spamhaus_HBL' in sData:
        status=sData['Spamhaus_HBL']['detection']
    elif 'YOROI_YOMI' in sData:
        status=sData['YOROI_YOMI']['detection']
    else:
        status='ok'
    return status

#check to see if there is vxCube or Triage to get the score
def checkscore(rawdata):
    if('vendor_intel'in rawdata):
        apicheck=rawdata['vendor_intel']
        if 'vxCube' in apicheck:
            score=apicheck['maliciousness']
        elif 'Triage' in apicheck:
            score=apicheck['Triage']*10
    else:
        score=0
    return score

def analyze(input):
    data = json.loads(input)
    meta = loadMetadataFix(__file__)
    print(meta)
    helpers.checkSupportedType(meta, data["artifactType"])
    if(data['artifactType'] == 'tlsh' ):
        nHash=prepare_tlshphash(data['value'])
        data['value']=nHash
    elif(data['artifactType'] == 'gimphash'):
        nHash= prepare_gimphash(data['value'])
        data['value']=nHash
    data["artifactType"]='hash'
    query = buildReq(data['artifactType'], data['value'])
    response = sendReq(meta, query)
    return prepareResults(response[0],response[1] )
#query the gimp hash to output the hash of the first malware

def prepare_gimphash(hash):
    data = json.loads(input)
    meta = loadMetadataFix(__file__)
    query=buildReq(data['artifactType'], hash)
    raw= sendReq(meta,query)
    return  raw['data'][0]['sha256_hash'], len(raw[data][0])
#query the tlsh hash to output the hash of the first malware
def prepare_tlshphash(hash):
    data = json.loads(input)
    meta = loadMetadataFix(__file__)
    query=buildReq(data['artifactType'], hash)
    raw= sendReq(meta,query)
    return raw['data'][0]['sha256_hash'], len(raw[data][0])

def sendReq(meta, query):
    url = meta['baseUrl']
    response = requests.post(url, json.dumps(query))
    return response.json()


def main():
    if len(sys.argv) == 2:
        results = analyze(sys.argv[1])
        print(json.dumps(results))
    else:
        print("ERROR: Input is not in proper JSON format")

if __name__ == '__main__':
    main()

# def initialQuery(querytype, searchtype, data):
#     response = requests.post('https://mb-api.abuse.ch/api/v1/', {'query':querytype, searchtype:data })
#     rawdata = response.json()
#     pprint(rawdata['data'][0])
#initialQuery('get_info', 'hash', '7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754')
#initialQuery('get_info', 'hash', 'db5b826657bdb58d6ec2956476f2702dfd6c51bb705e83934fb0ebc7b7a4ed03')

#initialQuery('get_tlsh', 'tlsh', '4FB44AC6A19643BBEE8766FF358AC55DBC13D91C1B4DB4FBC789AA020A31B05ED12350')
#initialQuery('get_gimphash', 'gimphash', '50f5783c2188897815d9b34a77aa4df70ac96a71542ddc79b94fef8ce7ba2120')

#6560ba1a1c5046ef58b32c96871949ea41a50f943977216b8b59a462e93ec58d
#initialQuery('get_ssdeep', 'ssdeep', '768:Bs0RHTX7bzsy+HfSzj9YTu1gAVHiLZkyN977uGnbcuyD7UryqF:W0hX7b9HiSnhiLt9Xtnouy8mqF')

#initialQuery('get_info', 'hash', '9e9fa8b3b0a59762b429853a36674608df1fa7d7f7140c8fccd7c1946070995a')

#initialQuery('get_info', 'hash', '2c3723ae043796895afb2aa8e6d465e65e1fc0b22dac84eb3db76f26f220e448')
#initialQuery('get_info', 'hash', '6560ba1a1c5046ef58b32c96871949ea41a50f943977216b8b59a462e93ec58d')

