import requests 
import helpers
import json
import sys
from pprint import pprint
import os
# support querying for hash, gimphash, tlsh, ssdeep

def buildReq(observ_type, observ_value):
    if observ_type == 'gimphash':
        qtype = 'get_gimphash'
    elif observ_type == 'tlsh':
        qtype = 'get_tlsh'
    else:
        qtype = 'get_info'
    return {'query': qtype, observ_type: observ_value}



#first layer is triage tags, then regular tags for summaries, 
#   for tlsh it is going to be number of malware then first malware data.
#       tlsh will be special that it will return number of malware
#       also dev an array of data that record all the API 
#for status first layer is vxcube, then triage[Triage][score], then reverse lab[ReversingLabs][status], then spamhaus[Spamhaus_HBL][detection], then yoroi_yomi (['YOROI_YOMI']['detection'])
def prepareResults(raw, countmal):
    if raw != {} and raw['query_status'] == 'ok':
        print('entered pR if block 1')
        parsed = raw['data'][0]
        if countmal>=1:
            summary=f'there are {countmal} malware associate with the hashes'
        #if there exist a tag then check for triage, if triage not aviaable then get the regular tags value
        else:
            if(parsed['tags']!=''):
                if(parsed['vendor_intel']['Triage']['tags']!=''):
                    summary = parsed['vendor_intel']['Triage']['tags']
            else:
                summary = parsed['tags']


        score = checkscore(parsed)
        if score!=0:
            if score > 75:
                status = 'threat'
            elif score > 50:
                status = 'caution'
            elif score > 25:
                status = 'info'
            else:
                status = 'ok'
        else:
            status=checkStatus(parsed)

    elif raw != {} and raw['query_status'] in ['no_result', 'illegal_hash', 'illegal_tlsh','illegal_gimphash','unknown_operation', 'no_gimphash','hash_not_found','no_hash_provided','http_post_expected','no_tlsh','no_results',]:
            status = 'info'
            summary = 'no result'
    else:
            raw = {}
            status = 'caution'
            summary = 'internal_failure'

    results = {'response': raw, 'summary': summary, 'status': status}    
    return results
# second check if there is no score then check these api to get the status
def checkStatus(sData):
    print('entered checkStatus')
    if 'ReversingLabs' in sData:
        status=sData['ReversingLabs']['status']
    elif 'Spamhaus_HBL' in sData:
        status=sData['Spamhaus_HBL']['detection']
    elif 'YOROI_YOMI' in sData:
        status=sData['YOROI_YOMI']['detection']
    else:
        status='ok'
    print(f'exited checkStatus with status value: {status}')
    return status

#check to see if there is vxCube or Triage to get the score
def checkscore(rawdata):
    print('entered checkscore')
    if('vendor_intel'in rawdata):
        apicheck=rawdata['vendor_intel']
        if 'vxCube' in apicheck:
            score=int(apicheck['vxCube']['maliciousness'])
        elif 'Triage' in apicheck:
            score=int(apicheck['Triage']['score'])*10
    else:
        score=0
    print(f'exited checkscore with score: {score}')
    return score

def analyze(input):
    data = json.loads(input)
    pprint(data)
    meta = helpers.loadMetadata(__file__)
    helpers.checkSupportedType(meta, data["artifactType"])
    countmal=0
    
    if(data['artifactType'] == 'tlsh' or data['artifactType'] == 'gimphash'):
        print('re-query necessary, executing oddHash')
        nHash=prepare_oddHash(data['value'], data)
        data['value']=nHash[0]
        countmal=nHash[1]
        data["artifactType"]='hash'
        print('prepared re-query')
    
    print('oddHash completed. executing re-query')
    query = buildReq(data['artifactType'], data['value'])
    response = sendReq(meta, query)
    return prepareResults(response, countmal)

def prepare_oddHash(hash, data):
    meta = helpers.loadMetadata(__file__)
    query=buildReq(data['artifactType'], hash)
    raw = sendReq(meta,query)
    print(f"Hash for requery: {raw['data'][0]['sha256_hash']}")
    pprint(raw)
    
    return raw['data'][0]['sha256_hash'], len(raw['data'])

def sendReq(meta, query):
    print('Starting sendReq...')
    url = meta['baseUrl']
    #REMOVE BELOW
    url = 'https://mb-api.abuse.ch/api/v1/'
    print('Sending request...')
    response = requests.post(url, query)
    return response.json()


def main():
    if len(sys.argv) == 2:
        results = analyze(sys.argv[1])
        pprint(results)
    else:
        print("ERROR: Input is not in proper JSON format")


if __name__ == '__main__':
    main()


# def initialQuery(querytype, searchtype, data):
#     response = requests.post('https://mb-api.abuse.ch/api/v1/', {'query':querytype, searchtype:data})
#     rawdata = response.json()
#     pprint(rawdata['data'][0])

#initialQuery('get_info', 'hash', '7de2c1bf58bce09eecc70476747d88a26163c3d6bb1d85235c24a558d1f16754')
#initialQuery('get_info', 'hash', 'db5b826657bdb58d6ec2956476f2702dfd6c51bb705e83934fb0ebc7b7a4ed03')

#initialQuery('get_tlsh', 'tlsh', '4FB44AC6A19643BBEE8766FF358AC55DBC13D91C1B4DB4FBC789AA020A31B05ED12350')
#initialQuery('get_gimphash', 'gimphash', '50f5783c2188897815d9b34a77aa4df70ac96a71542ddc79b94fef8ce7ba2120')

#6560ba1a1c5046ef58b32c96871949ea41a50f943977216b8b59a462e93ec58d
#initialQuery('get_ssdeep', 'ssdeep', '768:Bs0RHTX7bzsy+HfSzj9YTu1gAVHiLZkyN977uGnbcuyD7UryqF:W0hX7b9HiSnhiLt9Xtnouy8mqF')

#initialQuery('get_info', 'hash', '9e9fa8b3b0a59762b429853a36674608df1fa7d7f7140c8fccd7c1946070995a')

#initialQuery('get_info', 'hash', '2c3723ae043796895afb2aa8e6d465e65e1fc0b22dac84eb3db76f26f220e448')
#initialQuery('get_info', 'hash', '6560ba1a1c5046ef58b32c96871949ea41a50f943977216b8b59a462e93ec58d')

